<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테트리스</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        .game-container {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .game-board {
            width: 300px;
            height: 600px;
            border: 3px solid #333;
            background: #000;
            position: relative;
            overflow: hidden;
        }
        
        .block {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
            transition: all 0.2s ease;
        }
        
        .falling-block {
            transition: all 0.15s linear;
        }
        
        .info {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .score {
            color: #00ff00;
            margin-top: 15px;
            text-align: center;
            font-size: 16px;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            animation: gameOverFade 2s ease-in-out forwards;
        }
        
        @keyframes gameOverFade {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* 테트리스 블록 색상 */
        .color-0 { background: #000; }
        .color-1 { background: #ff6b6b; box-shadow: inset 2px 2px 4px rgba(255,255,255,0.3); }
        .color-2 { background: #4ecdc4; box-shadow: inset 2px 2px 4px rgba(255,255,255,0.3); }
        .color-3 { background: #45b7d1; box-shadow: inset 2px 2px 4px rgba(255,255,255,0.3); }
        .color-4 { background: #f9ca24; box-shadow: inset 2px 2px 4px rgba(255,255,255,0.3); }
        .color-5 { background: #6c5ce7; box-shadow: inset 2px 2px 4px rgba(255,255,255,0.3); }
        .color-6 { background: #a29bfe; box-shadow: inset 2px 2px 4px rgba(255,255,255,0.3); }
        .color-7 { background: #fd79a8; box-shadow: inset 2px 2px 4px rgba(255,255,255,0.3); }
        
        .clearing {
            animation: clearFlash 1s ease-in-out forwards;
        }
        
        @keyframes clearFlash {
            0%, 20%, 40%, 60%, 80% { 
                background: white; 
                opacity: 1; 
                transform: scale(1.1);
            }
            10%, 30%, 50%, 70%, 90% { 
                opacity: 0.3; 
                transform: scale(0.9);
            }
            100% { 
                opacity: 0; 
                transform: scale(0);
            }
        }
        
        .status {
            color: white;
            text-align: center;
            margin-top: 10px;
            font-size: 14px;
            min-height: 20px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="info">테트리스</div>
        <div class="game-board" id="gameBoard"></div>
        <div class="score">점수: <span id="score">0</span> | 라인: <span id="lines">0</span></div>
        <div class="status" id="status"></div>
    </div>

    <script>
        class Tetris {
            constructor() {
                this.board = Array(20).fill().map(() => Array(10).fill(0));
                this.gameBoard = document.getElementById('gameBoard');
                this.scoreElement = document.getElementById('score');
                this.linesElement = document.getElementById('lines');
                this.statusElement = document.getElementById('status');
                this.score = 0;
                this.lines = 0;
                this.currentPiece = null;
                this.currentX = 0;
                this.currentY = 0;
                this.isGameOver = false;
                this.successfulClears = 0; // 성공한 클리어 횟수
                
                // 테트리스 조각들
                this.pieces = [
                    {
                        shape: [[1,1,1,1]], // I
                        color: 1,
                        name: 'I'
                    },
                    {
                        shape: [[1,1],[1,1]], // O
                        color: 2,
                        name: 'O'
                    },
                    {
                        shape: [[0,1,0],[1,1,1]], // T
                        color: 3,
                        name: 'T'
                    },
                    {
                        shape: [[0,1,1],[1,1,0]], // S
                        color: 4,
                        name: 'S'
                    },
                    {
                        shape: [[1,1,0],[0,1,1]], // Z
                        color: 5,
                        name: 'Z'
                    },
                    {
                        shape: [[1,0,0],[1,1,1]], // J
                        color: 6,
                        name: 'J'
                    },
                    {
                        shape: [[0,0,1],[1,1,1]], // L
                        color: 7,
                        name: 'L'
                    }
                ];
                
                // 성공적인 게임 시나리오 (라인 클리어를 위한)
                this.successScenario = [
                    // 첫 번째 라인 클리어 세팅
                    {piece: 0, startX: 0, targetX: 0, rotations: 1, movements: []}, // I 세로
                    {piece: 6, startX: 4, targetX: 1, rotations: 0, movements: ['left','left','left']}, // L
                    {piece: 5, startX: 4, targetX: 4, rotations: 1, movements: []}, // J 회전
                    {piece: 3, startX: 4, targetX: 6, rotations: 0, movements: ['right','right']}, // S
                    {piece: 1, startX: 4, targetX: 8, rotations: 0, movements: ['right','right','right','right']}, // O
                    
                    // 두 번째 라인 클리어
                    {piece: 2, startX: 4, targetX: 2, rotations: 0, movements: ['left','left']}, // T
                    {piece: 4, startX: 4, targetX: 5, rotations: 0, movements: ['right']}, // Z
                    {piece: 0, startX: 4, targetX: 0, rotations: 0, movements: ['left','left','left','left']}, // I 가로
                    
                    // 세 번째 라인 클리어
                    {piece: 1, startX: 4, targetX: 0, rotations: 0, movements: ['left','left','left','left']}, // O
                    {piece: 6, startX: 4, targetX: 2, rotations: 2, movements: ['left','left','rotate','rotate']}, // L 회전
                    {piece: 5, startX: 4, targetX: 5, rotations: 0, movements: ['right']}, // J
                    {piece: 2, startX: 4, targetX: 7, rotations: 1, movements: ['right','right','right','rotate']}, // T 회전
                    {piece: 0, startX: 4, targetX: 4, rotations: 0, movements: []}, // I 가로
                    
                    // 네 번째 라인 클리어
                    {piece: 3, startX: 4, targetX: 1, rotations: 1, movements: ['left','left','left','rotate']}, // S 회전
                    {piece: 4, startX: 4, targetX: 4, rotations: 1, movements: ['rotate']}, // Z 회전
                    {piece: 1, startX: 4, targetX: 6, rotations: 0, movements: ['right','right']}, // O
                    {piece: 2, startX: 4, targetX: 8, rotations: 0, movements: ['right','right','right','right']}, // T
                    
                    // 다섯 번째 라인 클리어
                    {piece: 0, startX: 4, targetX: 0, rotations: 0, movements: ['left','left','left','left']}, // I 가로
                ];
                
                // 실패 시나리오 (잘못된 배치들)
                this.failScenario = [
                    {piece: 0, startX: 4, targetX: 2, rotations: 1, movements: ['left','left']}, // I 세로 잘못된 위치
                    {piece: 1, startX: 4, targetX: 0, rotations: 0, movements: ['left','left','left','left']}, // O 구석
                    {piece: 2, startX: 4, targetX: 8, rotations: 2, movements: ['right','right','right','right','rotate','rotate']}, // T 잘못 회전
                    {piece: 3, startX: 4, targetX: 1, rotations: 0, movements: ['left','left','left']}, // S 구석
                    {piece: 4, startX: 4, targetX: 7, rotations: 1, movements: ['right','right','right','rotate']}, // Z 잘못 배치
                    {piece: 5, startX: 4, targetX: 3, rotations: 0, movements: ['left']}, // J 중간
                    {piece: 6, startX: 4, targetX: 6, rotations: 1, movements: ['right','right','rotate']}, // L 회전
                    {piece: 0, startX: 4, targetX: 8, rotations: 1, movements: ['right','right','right','right']}, // I 세로 구석
                    {piece: 1, startX: 4, targetX: 4, rotations: 0, movements: []}, // O 중간
                    {piece: 2, startX: 4, targetX: 1, rotations: 1, movements: ['left','left','left','rotate']}, // T 잘못
                    {piece: 3, startX: 4, targetX: 7, rotations: 1, movements: ['right','right','right','rotate']}, // S
                    {piece: 4, startX: 4, targetX: 2, rotations: 0, movements: ['left','left']}, // Z
                    {piece: 5, startX: 4, targetX: 8, rotations: 2, movements: ['right','right','right','right','rotate','rotate']}, // J
                    {piece: 6, startX: 4, targetX: 0, rotations: 1, movements: ['left','left','left','left','rotate']}, // L
                    {piece: 0, startX: 4, targetX: 5, rotations: 1, movements: ['right']}, // 게임 오버 유발
                ];
                
                this.currentScenario = [];
                this.scenarioIndex = 0;
                this.init();
            }
            
            init() {
                // 성공 시나리오와 실패 시나리오 합치기
                this.currentScenario = [...this.successScenario, ...this.failScenario];
                this.render();
                this.spawnNextPiece();
            }
            
            spawnNextPiece() {
                if (this.scenarioIndex >= this.currentScenario.length) {
                    this.endGame();
                    return;
                }
                
                const scenario = this.currentScenario[this.scenarioIndex];
                const pieceTemplate = this.pieces[scenario.piece];
                
                this.currentPiece = {
                    shape: JSON.parse(JSON.stringify(pieceTemplate.shape)),
                    color: pieceTemplate.color,
                    name: pieceTemplate.name
                };
                
                this.currentX = scenario.startX;
                this.currentY = 0;
                
                if (this.checkCollision()) {
                    this.endGame();
                    return;
                }
                
                this.scenarioIndex++;
                this.executeMovements(scenario.movements, scenario.rotations);
            }
            
            async executeMovements(movements, rotations) {
                this.render();
                await this.wait(200);
                
                // 회전과 이동 실행
                for (let move of movements) {
                    if (move === 'rotate') {
                        this.rotatePiece();
                    } else if (move === 'left') {
                        this.currentX--;
                        if (this.checkCollision()) this.currentX++;
                    } else if (move === 'right') {
                        this.currentX++;
                        if (this.checkCollision()) this.currentX--;
                    }
                    this.render();
                    await this.wait(150);
                }
                
                // 추가 회전 (movements에 포함되지 않은)
                for (let i = 0; i < rotations; i++) {
                    this.rotatePiece();
                    this.render();
                    await this.wait(150);
                }
                
                this.dropPiece();
            }
            
            rotatePiece() {
                const oldShape = this.currentPiece.shape;
                const newShape = this.currentPiece.shape[0].map((_, index) =>
                    this.currentPiece.shape.map(row => row[index]).reverse()
                );
                this.currentPiece.shape = newShape;
                
                if (this.checkCollision()) {
                    this.currentPiece.shape = oldShape;
                }
            }
            
            async dropPiece() {
                // 빠르게 아래로 떨어뜨리기
                while (true) {
                    await this.wait(100);
                    this.currentY++;
                    if (this.checkCollision()) {
                        this.currentY--;
                        break;
                    }
                    this.render();
                }
                
                this.placePiece();
                this.render();
                
                await this.checkAndClearLines();
                
                setTimeout(() => {
                    if (!this.isGameOver) {
                        this.spawnNextPiece();
                    }
                }, 300);
            }
            
            checkCollision() {
                const shape = this.currentPiece.shape;
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x] && 
                           (this.currentX + x < 0 || 
                            this.currentX + x >= 10 || 
                            this.currentY + y >= 20 || 
                            (this.currentY + y >= 0 && this.board[this.currentY + y][this.currentX + x]))) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            placePiece() {
                const shape = this.currentPiece.shape;
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x] && this.currentY + y >= 0) {
                            this.board[this.currentY + y][this.currentX + x] = this.currentPiece.color;
                        }
                    }
                }
            }
            
            async checkAndClearLines() {
                const linesToClear = [];
                
                for (let y = 19; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== 0)) {
                        linesToClear.push(y);
                    }
                }
                
                if (linesToClear.length > 0) {
                    this.successfulClears++;
                    
                    if (this.successfulClears <= 5) {
                        this.statusElement.textContent = `라인 클리어! (${this.successfulClears}/5)`;
                    } else {
                        this.statusElement.textContent = "라인 클리어!";
                    }
                    
                    // 클리어 애니메이션
                    for (let lineY of linesToClear) {
                        for (let x = 0; x < 10; x++) {
                            const block = document.querySelector(`[data-row="${lineY}"][data-col="${x}"]`);
                            if (block) {
                                block.classList.add('clearing');
                            }
                        }
                    }
                    
                    await this.wait(1000);
                    
                    // 라인 제거
                    for (let lineY of linesToClear.sort((a, b) => b - a)) {
                        this.board.splice(lineY, 1);
                        this.board.unshift(Array(10).fill(0));
                    }
                    
                    this.lines += linesToClear.length;
                    this.score += linesToClear.length * 100 * linesToClear.length;
                    this.updateScore();
                    
                    this.render();
                    await this.wait(300);
                } else if (this.successfulClears >= 5) {
                    this.statusElement.textContent = "블록이 쌓이고 있습니다...";
                }
            }
            
            endGame() {
                this.statusElement.textContent = "게임 오버!";
                this.isGameOver = true;
                
                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.textContent = 'GAME OVER';
                this.gameBoard.appendChild(gameOverDiv);
                
                setTimeout(() => {
                    this.restart();
                }, 5000);
            }
            
            restart() {
                this.board = Array(20).fill().map(() => Array(10).fill(0));
                this.score = 0;
                this.lines = 0;
                this.scenarioIndex = 0;
                this.successfulClears = 0;
                this.isGameOver = false;
                this.updateScore();
                this.statusElement.textContent = "";
                
                const gameOverDiv = document.querySelector('.game-over');
                if (gameOverDiv) {
                    gameOverDiv.remove();
                }
                
                setTimeout(() => {
                    this.init();
                }, 2000);
            }
            
            render() {
                const existingBlocks = this.gameBoard.querySelectorAll('.block');
                existingBlocks.forEach(block => block.remove());
                
                // 보드 렌더링
                for (let y = 0; y < 20; y++) {
                    for (let x = 0; x < 10; x++) {
                        if (this.board[y][x] !== 0) {
                            const block = document.createElement('div');
                            block.className = `block color-${this.board[y][x]}`;
                            block.style.left = `${x * 30}px`;
                            block.style.top = `${y * 30}px`;
                            block.setAttribute('data-row', y);
                            block.setAttribute('data-col', x);
                            this.gameBoard.appendChild(block);
                        }
                    }
                }
                
                // 현재 조각 렌더링
                if (this.currentPiece && !this.isGameOver) {
                    const shape = this.currentPiece.shape;
                    for (let y = 0; y < shape.length; y++) {
                        for (let x = 0; x < shape[y].length; x++) {
                            if (shape[y][x] && this.currentY + y >= 0) {
                                const block = document.createElement('div');
                                block.className = `block color-${this.currentPiece.color} falling-block`;
                                block.style.left = `${(this.currentX + x) * 30}px`;
                                block.style.top = `${(this.currentY + y) * 30}px`;
                                this.gameBoard.appendChild(block);
                            }
                        }
                    }
                }
            }
            
            updateScore() {
                this.scoreElement.textContent = this.score;
                this.linesElement.textContent = this.lines;
            }
            
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        window.addEventListener('load', () => {
            new Tetris();
        });
    </script>
</body>
</html>