네, 제시해주신 기술 스택과 목표는 매우 훌륭하며, 7일이라는 짧은 시간 동안 성공적으로 완수하기 위해서는 체계적인 R&R(역할과 책임) 분담과 단계별 계획이 무엇보다 중요합니다. 비전공자 팀이라는 점을 감안하여, 복잡한 이론보다는 실행 가능한 MVP(Minimum Viable Product, 최소 기능 제품)를 만드는 데 초점을 맞춘 1부터 100까지의 로드맵을 구성해 드리겠습니다.

## 사전 준비: R&R(역할과 책임) 정의
먼저 4명의 팀원의 역할을 명확히 나눕니다. 7일 프로젝트에서는 한 사람이 여러 역할을 맡기보다 명확히 분담하는 것이 효율적입니다.

A - 인프라 담당 (Infra Lead): Azure 리소스 생성, AKS 클러스터 구축 및 관리, K8s Manifest 작성, Argo CD, Prometheus/Grafana 구축 및 연동을 책임집니다.

B - 백엔드 API 담당 (Backend Lead): 마이크로서비스 아키텍처 설계, 핵심 비즈니스 로직(게임, 랭킹) API 개발을 주도합니다.

C - 백엔드 지원 및 데이터 담당 (Backend & Data Support): B를 도와 API를 함께 개발하며, 특히 Redis를 활용한 매치메이킹 큐, 리더보드, 세션 관리 로직 구현에 집중합니다.

D - 프론트엔드 담당 (Frontend Lead): 사용자가 직접 상호작용하는 웹 앱(게임 화면, 로비, 리더보드)의 모든 UI/UX 개발을 책임집니다.

## 🚀 7일 프로젝트 단계별 로드맵 (1 → 100)
Phase 1: 설계 및 환경 구축 (1 ~ 20) / Day 1
목표: 모두가 같은 그림을 보고 달리도록 초석을 다진다.

[전원] 게임 선정 및 규칙 단순화 (1): 가장 중요합니다. GitHub에 있는 복잡한 게임 대신, 오목, 틱택토, 간단한 카드 게임 등 규칙이 매우 단순한 게임을 선정합니다. 7일 안에 완성하려면 게임 로직이 복잡하면 안 됩니다.

[B, C, D] API 명세서 작성 (5): 프론트엔드와 백엔드가 소통할 규칙(API Contract)을 먼저 정합니다. Swagger/OpenAPI 같은 툴을 사용해 아래와 같은 API 엔드포인트를 명확히 정의합니다.

POST /matchmaking/join (매칭 대기열 참가)

GET /matchmaking/status (매칭 상태 확인)

POST /game/{roomId}/move (게임 내 행동 전송)

GET /leaderboard (리더보드 조회)

[A, B] 마이크로서비스 설계 (10): 어떤 서비스로 쪼갤지 결정합니다. 최소 단위로 시작합니다.

user-service: 사용자 인증 및 정보 관리 (간단한 닉네임 기반으로 시작)

matchmaking-service: Redis를 이용해 매칭 대기열 관리

game-service: 실제 게임 로직 처리

leaderboard-service: Redis Sorted Set을 이용한 ELO 랭킹 관리

[A] 인프라 프로비저닝 (20): Azure Portal 또는 Terraform/CLI를 통해 프로젝트에 필요한 기본 리소스를 생성합니다.

리소스 그룹, AKS(Azure Kubernetes Service) 클러스터, ACR(Azure Container Registry), Azure Cache for Redis 인스턴스 생성.

Phase 2: 핵심 기능 개발 및 컨테이너화 (21 ~ 50) / Day 2-3
목표: 각 서비스가 독립적으로 실행될 수 있는 컨테이너(Docker 이미지)를 만든다.

[B, C] 백엔드 서비스 기본 구현 (35): API 명세에 따라 각 마이크로서비스의 기본 골격을 개발합니다. Node.js/Express나 Python/FastAPI처럼 개발 속도가 빠른 프레임워크를 추천합니다.

C: Redis 연결 로직을 구현하여 매칭 대기열에 사용자를 넣고 빼는 기능, Sorted Set에 점수를 기록하는 기능을 먼저 개발합니다.

B: 핵심 게임 로직(수 유효성 검사 등)과 ELO 점수 계산 로직을 개발합니다.

[D] 프론트엔드 UI/UX 프로토타입 개발 (40): 실제 서버 연동 없이, UI 컴포넌트(게임 보드, 버튼, 로비 화면)를 미리 만듭니다. '더미 데이터'를 사용해 화면이 어떻게 보일지 구현합니다.

[A, B, C] Dockerfile 작성 및 이미지 빌드 (50): 각 마이크로서비스를 실행할 수 있는 Dockerfile을 작성하고, 로컬 환경에서 테스트합니다. 빌드된 이미지를 **ACR(Azure Container Registry)**에 Push합니다.

Phase 3: 쿠버네티스 배포 및 통합 (51 ~ 80) / Day 4-5
목표: 컨테이너들을 K8s 클러스터에 배포하고, 서비스들이 서로 통신하게 만든다.

[A] K8s 기본 환경 구축 (60): AKS 클러스터에 Argo CD, Prometheus, Grafana를 설치합니다. (Helm 차트 사용을 권장)

Argo CD가 바라볼 GitOps용 GitHub Repository를 생성하고 구조를 잡습니다.

[A] K8s Manifest 작성 및 GitOps 구성 (70): 각 마이크로서비스를 위한 쿠버네티스 Deployment, Service, Ingress YAML 파일을 작성하여 GitOps 레포지토리에 Push합니다.

Argo CD가 Git 레포지토리의 변경을 감지하고, 자동으로 서비스들을 AKS 클러스터에 배포하도록 설정합니다.

[전원] 서비스 연동 및 통합 테스트 (80): 프로젝트의 가장 어려운 구간입니다.

D: 더미 데이터를 사용하던 프론트엔드 코드를 실제 배포된 백엔드 API 주소로 변경하고, WebSocket을 이용해 실시간 통신 기능을 구현합니다.

B, C: 배포된 환경에서 서비스 간 통신(예: 매칭 서비스가 게임 서비스를 호출)이 잘 되는지 확인하고, 로그를 보며 버그를 수정합니다.

A: Ingress 설정, 네트워크 정책 등 인프라 문제를 해결하고 트러블슈팅을 지원합니다.

Phase 4: 모니터링, 고도화 및 발표 준비 (81 ~ 100) / Day 6-7
목표: 완성된 서비스를 안정화하고, 프로젝트의 성과를 시각적으로 보여줄 준비를 한다.

[A] 모니터링 환경 구축 (85): Prometheus가 각 서비스의 Metric을 수집하도록 설정하고, Grafana에서 수집된 데이터를 시각화하는 대시보드를 만듭니다.

보여줄 만한 지표: 현재 매칭 대기 중인 유저 수, 진행 중인 게임 방의 수, API 요청 수 및 응답 시간 등

[B, C] ELO 랭킹 로직 고도화 (90): 기본 점수 기록 방식에서 실제 ELO 레이팅 계산 공식을 적용하여 승패에 따라 점수가 변동되도록 로직을 고도화합니다.

[D] 프론트엔드 완성도 향상 (95): 게임 시작/종료 팝업, 승패 연출, 랭킹 보드 UI 등 사용자 경험을 개선하는 작업을 진행합니다.

[전원] 최종 테스트 및 발표 준비 (100): 전체 시나리오(회원가입 → 매칭 → 게임 → 결과 확인 → 랭킹 보드 반영)를 반복 테스트하며 버그를 잡고, 각자 맡은 파트에 대한 발표 자료를 준비하고 시연을 연습합니다.

## 💡 성공을 위한 핵심 전략
API 명세서에 집착하세요: Day 1에 정의한 API 규칙은 7일 동안 절대 바꾸지 않는다는 생각으로 신중하게 결정해야 합니다. 이것이 흔들리면 모두가 혼란에 빠집니다.

단순하게 유지하세요 (Keep It Simple): 회원가입은 닉네임만으로, 게임은 가장 단순한 것으로, ELO 로직도 처음엔 단순히 승리 시 +10점, 패배 시 -5점으로 시작하는 등 모든 것을 MVP에 맞게 단순화해야 합니다.

매일 아침 15분 스크럼: 매일 정해진 시간에 각자 어제 한 일, 오늘 할 일, 어려운 점을 공유하여 팀 전체의 진행 상황을 투명하게 유지하세요.