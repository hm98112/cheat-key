<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS BATTLE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; font-family: 'Roboto', sans-serif; background-color: #1a1a2e; color: white; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        body.shake { animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        .main-container { position: relative; width: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .content-box { background-color: rgba(26, 26, 46, 0.8); border: 1px solid rgba(255, 255, 255, 0.2); padding: 30px; border-radius: 15px; text-align: center; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); width: 95%; max-width: 900px; }
        #status { font-size: 1.5em; margin-bottom: 20px; color: #e0e0e0; height: 30px; }
        .game-container { display: flex; gap: 20px; justify-content: center; align-items: flex-start; }
        .player-area { position: relative; text-align: center; color: #ccc; }
        .side-area { display: flex; flex-direction: column; align-items: center; margin-top: 50px; width: 120px; }
        .side-area h3 { margin-top: 0; margin-bottom: 10px; color: #9BF6FF; font-weight: 400; }
        h2 { margin-top: 0; margin-bottom: 15px; font-weight: 400; }
        canvas { border: 2px solid #4f4f8e; background-color: #0f0f1e; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
        .info { background-color: #0f0f1e; border: 1px solid #4f4f8e; border-radius: 8px; padding: 8px 15px; margin-top: 15px; font-size: 1.1em; display: inline-block; }
        #opponent-overlay { position: absolute; top: 42px; left: 0; width: 100%; height: calc(100% - 42px); background-color: rgba(0, 0, 0, 0.7); color: white; display: flex; justify-content: center; align-items: center; font-size: 1.2em; border-radius: 8px; z-index: 10; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="content-box">
            <h1 id="status">서버에 연결 중...</h1>
    
            <div class="game-container">
                <div class="side-area">
                    <h3>홀드 (C)</h3>
                    <canvas id="hold-canvas" width="96" height="96"></canvas>
                </div>

                <div class="player-area">
                    <h2>나 (You)</h2>
                    <canvas id="player-board" width="240" height="480"></canvas>
                    <div class="info">점수: <span id="player-score">0</span></div>
                </div>

                <div class="side-area">
                    <h3>다음 블록</h3>
                    <canvas id="next-piece-canvas" width="96" height="96"></canvas>
                </div>
                
                <div class="player-area">
                    <h2>상대방 (Opponent)</h2>
                    <canvas id="opponent-board" width="240" height="480"></canvas>
                    <div id="opponent-overlay">상대방을 기다리는 중...</div>
                    <div class="info">점수: <span id="opponent-score">0</span></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const socket = io('http://localhost:3001');
        const COLS = 10, ROWS = 20, BLOCK_SIZE = 24;
        
        const playerCanvas = document.getElementById('player-board'), playerCtx = playerCanvas.getContext('2d');
        const opponentCanvas = document.getElementById('opponent-board'), opponentCtx = opponentCanvas.getContext('2d');
        const nextPieceCanvas = document.getElementById('next-piece-canvas'), nextPieceCtx = nextPieceCanvas.getContext('2d');
        const holdCanvas = document.getElementById('hold-canvas'), holdCtx = holdCanvas.getContext('2d');
        const statusEl = document.getElementById('status'), playerScoreEl = document.getElementById('player-score'), opponentScoreEl = document.getElementById('opponent-score');
        const opponentOverlay = document.getElementById('opponent-overlay');

        const COLORS = [null, '#FFADAD', '#FFD6A5', '#FDFFB6', '#CAFFBF', '#9BF6FF', '#A0C4FF', '#BDB2FF', '#606060'];
        const SHAPES = [[], [[1,1,1,1]], [[2,2],[2,2]], [[0,3,3],[3,3,0]], [[4,4,0],[0,4,4]], [[5,0,0],[5,5,5]], [[0,0,6],[6,6,6]], [[0,7,0],[7,7,7]]];
        
        const SRS_KICK_DATA = {JLSTZ: {'0-1':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],'1-0':[[0,0],[1,0],[1,-1],[0,2],[1,2]],'1-2':[[0,0],[1,0],[1,-1],[0,2],[1,2]],'2-1':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],'2-3':[[0,0],[1,0],[1,1],[0,-2],[1,-2]],'3-2':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],'3-0':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],'0-3':[[0,0],[1,0],[1,1],[0,-2],[1,-2]]},I:{'0-1':[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],'1-0':[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],'1-2':[[0,0],[-1,0],[2,0],[-1,2],[2,-1]],'2-1':[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],'2-3':[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],'3-2':[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],'3-0':[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],'0-3':[[0,0],[-1,0],[2,0],[-1,2],[2,-1]]}};

        let room = null, board = createEmptyBoard(), player = null, score = 0, gameOver = false, nextPiece = null;
        let lastTime = 0, dropCounter = 0, dropInterval = 1000;
        let pieceSequence = [], pieceIndex = 0;

        const keysDown = {};
        const DAS_DELAY = 160, DAS_INTERVAL = 40;
        let dasTimer = 0;
        
        let ghostPiece = null;
        let floatingTexts = [];
        let holdPieceType = null;
        let canHold = true;
        
        let isRequestingPieces = false;

        drawBoard(createEmptyBoard(), playerCtx);
        drawBoard(createEmptyBoard(), opponentCtx);

        function createEmptyBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }
        
        async function resetPlayer() {
            if (pieceSequence.length - pieceIndex <= 10 && !isRequestingPieces) {
                isRequestingPieces = true;
                socket.emit('requestMorePieces', { room });
            }
            while (pieceIndex >= pieceSequence.length) {
                if (gameOver) return;
                console.log("블록 소진! 서버로부터 새 블록을 기다립니다...");
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const typeId = pieceSequence[pieceIndex++];

            if (pieceIndex > 0 && pieceIndex % 15 === 0) {
                dropInterval = Math.max(100, dropInterval - 75);
            }

            const nextTypeId = pieceSequence[pieceIndex];
            const matrix = SHAPES[typeId];

            player = { 
                pos: { x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2), y: 0 },
                matrix: matrix, 
                typeId: typeId,
                rotationState: 0
            };
            
            nextPiece = nextTypeId ? { matrix: SHAPES[nextTypeId] } : null;

            if (isColliding(board, player)) {
                gameOver = true;
                socket.emit('gameOver', { room });
                statusEl.textContent = '게임 오버! 당신이 졌습니다.';
            }
            canHold = true;
            updateGhostPiece();
        }
        
        function draw() {
            drawBoard(board, playerCtx);
            if (ghostPiece) drawMatrix(ghostPiece.matrix, ghostPiece.pos, playerCtx, true);
            if (player) drawMatrix(player.matrix, player.pos, playerCtx, false);
            drawFloatingTexts(playerCtx);
            drawSideCanvas(nextPiece, nextPieceCtx);
            drawSideCanvas(holdPieceType ? { matrix: SHAPES[holdPieceType] } : null, holdCtx);
        }
        
        function drawBoard(boardData, ctx) {
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            boardData.forEach((row, y) => row.forEach((value, x) => {
                if (value !== 0) drawBlock(x, y, value, ctx);
            }));
        }
        
        function drawMatrix(matrix, offset, ctx, isGhost = false) {
            matrix.forEach((row, y) => row.forEach((value, x) => {
                if (value !== 0) drawBlock(x + offset.x, y + offset.y, value, ctx, isGhost);
            }));
        }

        function drawBlock(x, y, value, ctx, isGhost = false) {
            ctx.fillStyle = COLORS[value];
            if (isGhost) ctx.globalAlpha = 0.3;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            if (isGhost) ctx.globalAlpha = 1.0;
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        function drawSideCanvas(piece, ctx) {
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            if (piece) {
                const matrix = piece.matrix;
                const offsetX = (ctx.canvas.width / BLOCK_SIZE - matrix[0].length) / 2;
                const offsetY = (ctx.canvas.height / BLOCK_SIZE - matrix.length) / 2;
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) drawBlock(x + offsetX, y + offsetY, value, ctx);
                    });
                });
            }
        }
        
        function isColliding(board, piece) {
            for (let y = 0; y < piece.matrix.length; y++) {
                for (let x = 0; x < piece.matrix[y].length; x++) {
                    if (piece.matrix[y][x] !== 0) {
                        let newX = piece.pos.x + x;
                        let newY = piece.pos.y + y;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (board[newY] && board[newY][newX] !== 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function merge(board, player) {
            player.matrix.forEach((row, y) => row.forEach((value, x) => {
                if (value !== 0) board[y + player.pos.y][x + player.pos.x] = value;
            }));
        }
        
        async function clearLines() {
            let clearedLines = 0;
            outer: for (let y = board.length - 1; y >= 0; y--) {
                for (let x = 0; x < board[y].length; x++) if (board[y][x] === 0) continue outer;
                board.splice(y, 1);
                board.unshift(Array(COLS).fill(0));
                y++;
                clearedLines++;
            }
            if (clearedLines > 0) {
                const lineScore = [0, 100, 300, 500, 800][clearedLines];
                score += lineScore;
                playerScoreEl.textContent = score;
                addFloatingText(['', 'SINGLE', 'DOUBLE', 'TRIPLE', 'TETRIS!'][clearedLines], player.pos.x * BLOCK_SIZE, player.pos.y * BLOCK_SIZE);
                addFloatingText(`+${lineScore}`, player.pos.x * BLOCK_SIZE, player.pos.y * BLOCK_SIZE + 30);
                if (clearedLines >= 2) triggerScreenShake();
                socket.emit('lineClear', { lines: clearedLines, room });
            }
        }
        
        function addGarbageLines(count) {
            for (let i = 0; i < count; i++) {
                const row = Array(COLS).fill(8);
                row[Math.floor(Math.random() * COLS)] = 0;
                board.shift();
                board.push(row);
            }
            updateGhostPiece();
        }
        
        function update(time = 0) {
            if (gameOver) return;
            const deltaTime = time - lastTime;
            lastTime = time;

            const moveDir = (keysDown.ArrowLeft ? -1 : 0) + (keysDown.ArrowRight ? 1 : 0);
            if (moveDir !== 0) {
                dasTimer += deltaTime;
                if (dasTimer > DAS_DELAY) playerMove(moveDir);
            }
            
            const currentDropInterval = keysDown.ArrowDown ? 50 : dropInterval;
            dropCounter += deltaTime;
            if (dropCounter > currentDropInterval) playerDrop();

            draw();
            requestAnimationFrame(update);
        }
        
        function playerMove(dir) {
            if (gameOver) return;
            player.pos.x += dir;
            if (isColliding(board, player)) {
                player.pos.x -= dir;
            } else {
                updateGhostPiece();
            }
        }
        
        async function playerDrop() {
            if (gameOver || !player) return;
            player.pos.y++;
            if (isColliding(board, player)) {
                player.pos.y--;
                merge(board, player);
                await clearLines();
                await resetPlayer();
            }
            dropCounter = 0;
        }

        async function playerHardDrop() {
            if (gameOver || !player) return;
            player.pos.y = ghostPiece.pos.y;
            merge(board, player);
            await clearLines();
            await resetPlayer();
            dropCounter = 0;
        }

        function playerRotate(direction) {
            if (gameOver || !player || player.typeId === 2) return;

            const originalState = player.rotationState;
            const originalPos = { x: player.pos.x, y: player.pos.y };
            const originalMatrix = player.matrix;
            
            let rotated = player.matrix;
            if (direction === 1) {
                rotated = rotated[0].map((_, colIndex) => rotated.map(row => row[colIndex]).reverse());
            } else {
                for (let i = 0; i < 3; i++) {
                    rotated = rotated[0].map((_, colIndex) => rotated.map(row => row[colIndex]).reverse());
                }
            }
            player.matrix = rotated;

            let newState = (originalState + direction + 4) % 4;
            
            const kickTableType = (player.typeId === 1) ? 'I' : 'JLSTZ';
            const transitionKey = `${originalState}-${newState}`;
            const kickTests = SRS_KICK_DATA[kickTableType][transitionKey];
            
            for (const [x, y] of kickTests) {
                player.pos.x = originalPos.x + x;
                player.pos.y = originalPos.y - y;
                if (!isColliding(board, player)) {
                    player.rotationState = newState;
                    updateGhostPiece();
                    return;
                }
            }

            player.matrix = originalMatrix;
            player.pos = originalPos;
        }
        
        async function playerHold() {
            if (gameOver || !canHold) return;
            if (holdPieceType === null) {
                holdPieceType = player.typeId;
                await resetPlayer();
            } else {
                const newPlayerType = holdPieceType;
                holdPieceType = player.typeId;
                const matrix = SHAPES[newPlayerType];
                player = {
                    pos: { x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2), y: 0 },
                    matrix: matrix, typeId: newPlayerType, rotationState: 0
                };
                if (isColliding(board, player)) {
                    gameOver = true;
                    statusEl.textContent = '게임 오버!';
                    socket.emit('gameOver', { room });
                }
            }
            canHold = false;
            updateGhostPiece();
        }

        function updateGhostPiece() {
            if (!player) return;
            ghostPiece = JSON.parse(JSON.stringify(player));
            while (!isColliding(board, ghostPiece)) {
                ghostPiece.pos.y++;
            }
            ghostPiece.pos.y--;
        }

        function addFloatingText(text, x, y) {
            floatingTexts.push({ text, x: x + 40, y, life: 1 });
        }

        function drawFloatingTexts(ctx) {
            ctx.font = 'bold 24px Roboto';
            ctx.textAlign = 'center';
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ctx.fillStyle = `rgba(255, 255, 255, ${ft.life})`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ft.y -= 1;
                ft.life -= 0.02;
                if (ft.life <= 0) floatingTexts.splice(i, 1);
            }
        }

        function triggerScreenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 300);
        }
        
        document.addEventListener('keydown', e => {
            if (!player || gameOver) return;
            if (!keysDown[e.key]) {
                if (e.key === 'ArrowLeft') playerMove(-1);
                else if (e.key === 'ArrowRight') playerMove(1);
                else if (e.key === 'ArrowUp') playerRotate(1);
                else if (e.key === 'c' || e.key === 'C') playerHold();
                else if (e.key === ' ') { e.preventDefault(); playerHardDrop(); }
            }
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'c', 'C'].includes(e.key)) { e.preventDefault(); }
            keysDown[e.key] = true;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') dasTimer = 0;
        });

        document.addEventListener('keyup', e => {
            keysDown[e.key] = false;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') dasTimer = 0;
        });

        socket.on('connect', () => statusEl.textContent = '연결 성공! 다른 플레이어를 기다리는 중...');
        socket.on('waiting', () => statusEl.textContent = '다른 플레이어를 기다리는 중...');
        
        socket.on('gameStart', data => {
            room = data.room;
            pieceSequence = data.pieceSequence;
            pieceIndex = 0;
            statusEl.textContent = '게임 시작!';
            opponentOverlay.style.display = 'none';
            resetPlayer();
            update();
            setInterval(() => {
                if (!gameOver) socket.emit('boardState', { board, score, player, room, senderId: socket.id });
            }, 50);
        });
        
        socket.on('opponentState', (opponentState) => {
            if (socket.id !== opponentState.senderId) {
                drawBoard(opponentState.board, opponentCtx);
                if (opponentState.player) drawMatrix(opponentState.player.matrix, opponentState.player.pos, opponentCtx);
                opponentScoreEl.textContent = opponentState.score;
            }
        });

        socket.on('addMorePieces', (data) => {
            pieceSequence.push(...data.newPieces);
            isRequestingPieces = false;
            console.log('서버로부터 새 블록을 받았습니다. 총 블록 수:', pieceSequence.length);
        });

        socket.on('addGarbage', count => addGarbageLines(count));
        socket.on('opponentWin', () => { gameOver = true; statusEl.textContent = '승리했습니다!'; });
    </script>
</body>
</html>