<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS BATTLE - Dynamic Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            transition: transform 0.1s ease-in-out;
        }

        body.shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        .main-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .content-box {
            position: relative;
            background-color: rgba(26, 26, 46, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 95%;
            max-width: 900px;
            overflow: hidden;
        }

        .content-box::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                transparent,
                rgba(168, 85, 247, 0.8),
                rgba(79, 70, 229, 0.8),
                transparent 30%
            );
            animation: rotate 6s linear infinite;
        }

        @keyframes rotate {
            100% {
                transform: rotate(360deg);
            }
        }

        .inner-content {
            position: relative;
            background-color: #1a1a2e;
            padding: 20px;
            border-radius: 10px;
            z-index: 1;
        }

        #status {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #e0e0e0;
            height: 30px;
            text-shadow: 0 0 5px #fff;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }

        .player-area, .side-area {
            text-align: center;
            color: #ccc;
        }

        .side-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 50px;
            width: 120px;
        }

        .side-box {
            width: 100%;
            margin-bottom: 20px;
        }

        .side-box h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #9BF6FF;
            font-weight: 400;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-weight: 400;
        }

        canvas {
            border: 2px solid #4f4f8e;
            background-color: #0f0f1e;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        #player-board-container {
            position: relative;
        }

        .info {
            background-color: #0f0f1e;
            border: 1px solid #4f4f8e;
            border-radius: 8px;
            padding: 8px 15px;
            margin-top: 15px;
            font-size: 1.1em;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="content-box">
            <div class="inner-content">
                <h1 id="status">서버에 연결 중...</h1>
        
                <div class="game-container">
                    <div class="side-area">
                        <div class="side-box">
                            <h3>홀드 (C)</h3>
                            <canvas id="hold-canvas" width="96" height="96"></canvas>
                        </div>
                    </div>
                    
                    <div class="player-area">
                        <h2>나 (You)</h2>
                        <div id="player-board-container">
                            <canvas id="player-board" width="240" height="480"></canvas>
                        </div>
                        <div class="info">점수: <span id="player-score">0</span></div>
                    </div>

                    <div class="side-area">
                        <div class="side-box">
                            <h3>다음 블록</h3>
                            <canvas id="next-piece-canvas" width="96" height="96"></canvas>
                        </div>
                    </div>
                    
                    <div class="player-area">
                        <h2>상대방 (Opponent)</h2>
                        <canvas id="opponent-board" width="240" height="480"></canvas>
                        <div class="info">점수: <span id="opponent-score">0</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io('http://localhost:3001');
        const COLS = 10, ROWS = 20, BLOCK_SIZE = 24;
        
        const playerCanvas = document.getElementById('player-board'), playerCtx = playerCanvas.getContext('2d');
        const opponentCanvas = document.getElementById('opponent-board'), opponentCtx = opponentCanvas.getContext('2d');
        const nextPieceCanvas = document.getElementById('next-piece-canvas'), nextPieceCtx = nextPieceCanvas.getContext('2d');
        const holdCanvas = document.getElementById('hold-canvas'), holdCtx = holdCanvas.getContext('2d');
        
        const statusEl = document.getElementById('status'), playerScoreEl = document.getElementById('player-score'), opponentScoreEl = document.getElementById('opponent-score');
        
        const COLORS = [null, '#FFADAD', '#FFD6A5', '#FDFFB6', '#CAFFBF', '#9BF6FF', '#A0C4FF', '#BDB2FF', '#606060'];
        const SHAPES = [[], [[1,1,1,1]], [[2,2],[2,2]], [[0,3,3],[3,3,0]], [[4,4,0],[0,4,4]], [[5,0,0],[5,5,5]], [[0,0,6],[6,6,6]], [[0,7,0],[7,7,7]]];
        const T_PIECE_ID = 7;
        const DAS_DELAY = 160;
        const DAS_INTERVAL = 40;
        
        let room = null, board = createEmptyBoard(), player = null, score = 0, gameOver = false, nextPiece = null;
        let lastTime = 0, dropCounter = 0, dropInterval = 1000;
        let pieceSequence = [], pieceIndex = 0;

        let ghostPiece = null;
        let holdPieceType = null;
        let canHold = true;
        let floatingTexts = [];
        let lastMoveWasRotation = false;
        let isRequestingPieces = false;
        let isLocking = false; // (추가 1/4) 블록이 잠기는 동안 입력을 막기 위한 플래그

        const keysDown = {};
        let dasTimer = 0;

        function createEmptyBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }
        
        function resetPlayer() {
            if (pieceSequence.length - pieceIndex <= 10 && !isRequestingPieces) {
                isRequestingPieces = true;
                socket.emit('requestMorePieces', { room });
            }

            const typeId = pieceSequence[pieceIndex++];
            if (!typeId) {
                console.error("도형 순서가 모두 소진되었습니다. 서버 응답을 기다립니다...");
                setTimeout(resetPlayer, 500);
                return;
            }

            if (pieceIndex > 0 && pieceIndex % 20 === 0) {
                dropInterval = Math.max(100, dropInterval - 75);
            }

            const matrix = SHAPES[typeId];
            player = { 
                pos: { x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2), y: 0 },
                matrix: matrix, 
                typeId: typeId 
            };
            
            const nextTypeId = pieceSequence[pieceIndex];
            if (nextTypeId) {
                nextPiece = { pos: { x: 0, y: 0 }, matrix: SHAPES[nextTypeId], typeId: nextTypeId };
            } else {
                nextPiece = null;
            }

            if (isColliding(board, player)) {
                gameOver = true;
                socket.emit('gameOver', { room });
                statusEl.textContent = '게임 오버! 당신이 졌습니다.';
            }

            updateGhostPiece();
            canHold = true;
            lastMoveWasRotation = false;
            isLocking = false; // (추가 4/4) 새 블록 준비 완료 후 잠금 상태 해제
        }
        
        function draw() {
            drawBoard(board, playerCtx);
            if (ghostPiece) drawMatrix(ghostPiece.matrix, ghostPiece.pos, playerCtx, true);
            if (player) drawMatrix(player.matrix, player.pos, playerCtx);
            drawFloatingTexts(playerCtx);
            drawSideCanvas(nextPiece, nextPieceCtx);
            drawSideCanvas(holdPieceType ? { matrix: SHAPES[holdPieceType] } : null, holdCtx);
        }
        
        function drawBoard(boardData, ctx) {
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            boardData.forEach((row, y) => row.forEach((value, x) => {
                if (value !== 0) drawBlock(x, y, value, ctx);
            }));
        }
        
        function drawMatrix(matrix, offset, ctx, isGhost = false) {
            matrix.forEach((row, y) => row.forEach((value, x) => {
                if (value !== 0) drawBlock(x + offset.x, y + offset.y, value, ctx, isGhost);
            }));
        }

        function drawBlock(x, y, value, ctx, isGhost = false) {
            ctx.fillStyle = COLORS[value];
            if (isGhost) ctx.globalAlpha = 0.3;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            if (isGhost) ctx.globalAlpha = 1.0;
        }
        
        function drawSideCanvas(piece, ctx) {
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            if (piece) {
                const matrix = piece.matrix;
                const offsetX = (ctx.canvas.width / BLOCK_SIZE - matrix[0].length) / 2;
                const offsetY = (ctx.canvas.height / BLOCK_SIZE - matrix.length) / 2;
                drawMatrix(matrix, {x: offsetX, y: offsetY}, ctx);
            }
        }
        
        function isColliding(board, player) {
            for (let y = 0; y < player.matrix.length; y++) {
                for (let x = 0; x < player.matrix[y].length; x++) {
                    if (player.matrix[y][x] !== 0 && 
                        (board[y + player.pos.y] && board[y + player.pos.y][x + player.pos.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function merge(board, player) {
            player.matrix.forEach((row, y) => row.forEach((value, x) => {
                if (value !== 0) board[y + player.pos.y][x + player.pos.x] = value;
            }));
        }
        
        function clearLines() {
            let clearedLines = 0;
            let isTSpin = false;

            if (lastMoveWasRotation && player.typeId === T_PIECE_ID) {
                const {x, y} = player.pos;
                const corners = [[y, x], [y, x+2], [y+2, x], [y+2, x+2]];
                let filledCorners = 0;
                corners.forEach(([cy, cx]) => {
                    if (cy >= ROWS || cx < 0 || cx >= COLS || (board[cy] && board[cy][cx] !== 0)) {
                        filledCorners++;
                    }
                });
                if (filledCorners >= 3) isTSpin = true;
            }

            outer: for (let y = board.length - 1; y >= 0; y--) {
                for (let x = 0; x < board[y].length; x++) if (board[y][x] === 0) continue outer;
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                y++;
                clearedLines++;
            }
            if (clearedLines > 0) {
                let lineScore = 0;
                let eventText = "";

                if (isTSpin) {
                    lineScore = [0, 800, 1200, 1600][clearedLines];
                    eventText = `T-SPIN ${['', 'SINGLE', 'DOUBLE', 'TRIPLE'][clearedLines]}!`;
                } else {
                    lineScore = [0, 100, 300, 500, 800][clearedLines];
                    eventText = ['', 'SINGLE', 'DOUBLE', 'TRIPLE', 'TETRIS!'][clearedLines];
                }
                
                score += lineScore;
                playerScoreEl.textContent = score;

                addFloatingText(eventText, player.pos.x * BLOCK_SIZE + 50, player.pos.y * BLOCK_SIZE);
                addFloatingText(`+${lineScore}`, player.pos.x * BLOCK_SIZE + 50, player.pos.y * BLOCK_SIZE + 30);
                
                if (clearedLines >= 2 || isTSpin) triggerScreenShake();
                
                if (clearedLines > 1) {
                    socket.emit('lineClear', { lines: clearedLines, room });
                }
            }
        }
        
        function addGarbageLines(count) {
            for (let i = 0; i < count; i++) {
                const row = Array(COLS).fill(8);
                row[Math.floor(Math.random() * COLS)] = 0;
                board.shift();
                board.push(row);
            }
            updateGhostPiece();
        }

        function updateGhostPiece() {
            if (!player) return;
            ghostPiece = { ...player, pos: { ...player.pos } };
            while (!isColliding(board, ghostPiece)) {
                ghostPiece.pos.y++;
            }
            ghostPiece.pos.y--;
        }

        function addFloatingText(text, x, y) {
            floatingTexts.push({ text, x, y, life: 1, alpha: 1 });
        }

        function drawFloatingTexts(ctx) {
            ctx.font = 'bold 24px Roboto';
            ctx.textAlign = 'center';
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ctx.fillStyle = `rgba(255, 255, 255, ${ft.alpha})`;
                ctx.fillText(ft.text, ft.x, ft.y);
                ft.y -= 1;
                ft.life -= 0.02;
                ft.alpha = ft.life;
                if (ft.life <= 0) floatingTexts.splice(i, 1);
            }
        }

        function triggerScreenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 300);
        }
        
        function update(time = 0) {
            if (gameOver) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            handleDAS(deltaTime);
            const currentDropInterval = keysDown.ArrowDown ? 50 : dropInterval;
            dropCounter += deltaTime;
            if (dropCounter > currentDropInterval) playerDrop();
            draw();
            requestAnimationFrame(update);
        }

        function handleDAS(deltaTime) {
            const moveDir = (keysDown.ArrowLeft ? -1 : 0) + (keysDown.ArrowRight ? 1 : 0);
            if (moveDir !== 0) {
                if (dasTimer === 0) playerMove(moveDir);
                dasTimer += deltaTime;
                if (dasTimer > DAS_DELAY) {
                    const steps = Math.floor((dasTimer - DAS_DELAY) / DAS_INTERVAL);
                    for (let i = 0; i < steps; i++) playerMove(moveDir);
                    dasTimer = DAS_DELAY + (dasTimer - DAS_DELAY) % DAS_INTERVAL;
                }
            } else {
                dasTimer = 0;
            }
        }
        
        function playerMove(dir) {
            if (gameOver) return;
            player.pos.x += dir;
            if (isColliding(board, player)) {
                player.pos.x -= dir;
            } else {
                updateGhostPiece();
                lastMoveWasRotation = false;
            }
        }
        
        function playerDrop() {
            if (gameOver) return;
            player.pos.y++;
            if (isColliding(board, player)) {
                player.pos.y--;
                isLocking = true; // (추가 3/4) 잠금 상태 시작
                merge(board, player);
                clearLines();
                resetPlayer();
            } else {
                lastMoveWasRotation = false;
            }
            dropCounter = 0;
        }

        function playerHardDrop() {
            if (gameOver || !player) return;
            player.pos.y = ghostPiece.pos.y;
            isLocking = true; // (추가 3/4) 잠금 상태 시작
            merge(board, player);
            clearLines();
            resetPlayer();
            dropCounter = 0;
        }
        
        function playerRotate() {
            if (gameOver) return;
            const originalMatrix = player.matrix;
            const rotated = originalMatrix[0].map((_, colIndex) => originalMatrix.map(row => row[colIndex]).reverse());
            player.matrix = rotated;
            let offset = 1;
            while(isColliding(board, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    player.pos.x -= (offset -1);
                    player.matrix = originalMatrix;
                    return;
                }
            }
            updateGhostPiece();
            lastMoveWasRotation = true;
        }

        function playerHold() {
            if (gameOver || !canHold) return;
            if (holdPieceType === null) {
                holdPieceType = player.typeId;
                resetPlayer();
            } else {
                [holdPieceType, player.typeId] = [player.typeId, holdPieceType];
                const matrix = SHAPES[player.typeId];
                player.matrix = matrix;
                player.pos = { x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2), y: 0 };
                if (isColliding(board, player)) {
                    gameOver = true;
                    socket.emit('gameOver', { room });
                    statusEl.textContent = '게임 오버! 당신이 졌습니다.';
                }
            }
            updateGhostPiece();
            canHold = false;
        }
        
        document.addEventListener('keydown', e => {
            // (수정 2/4) isLocking이 true이면 아무것도 하지 않고 함수를 즉시 종료
            if (!player || gameOver || isLocking) return;

            if (!keysDown[e.key]) {
                switch(e.key) {
                    case 'ArrowUp': playerRotate(); break;
                    case ' ': e.preventDefault(); playerHardDrop(); break;
                    case 'c': case 'C': playerHold(); break;
                }
            }
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'c', 'C'].includes(e.key)) e.preventDefault();
            keysDown[e.key] = true;
        });

        document.addEventListener('keyup', e => {
            keysDown[e.key] = false;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') dasTimer = 0;
        });

        socket.on('connect', () => statusEl.textContent = '연결 성공! 다른 플레이어를 기다리는 중...');
        socket.on('waiting', () => statusEl.textContent = '다른 플레이어를 기다리는 중...');
        
        socket.on('addMorePieces', (data) => {
            pieceSequence.push(...data.newPieces);
            isRequestingPieces = false;
            console.log('서버로부터 새 블록 50개를 받았습니다. 총 블록 수:', pieceSequence.length);
        });

        socket.on('gameStart', data => {
            room = data.room;
            pieceSequence = data.pieceSequence;
            pieceIndex = 0;
            statusEl.textContent = '게임 시작!';
            resetPlayer();
            update();
            setInterval(() => {
                if (!gameOver) socket.emit('boardState', { board, score, player, room });
            }, 50);
        });
        
        socket.on('opponentState', (opponentState) => {
            drawBoard(opponentState.board, opponentCtx);
            if (opponentState.player) drawMatrix(opponentState.player.matrix, opponentState.player.pos, opponentCtx);
            opponentScoreEl.textContent = opponentState.score;
        });

        socket.on('addGarbage', count => addGarbageLines(count));
        socket.on('opponentWin', () => {
            gameOver = true;
            statusEl.textContent = '승리했습니다!';
        });
    </script>
</body>
</html>